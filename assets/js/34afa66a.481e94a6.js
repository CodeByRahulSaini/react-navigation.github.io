"use strict";(self.webpackChunkreact_navigation_website_next=self.webpackChunkreact_navigation_website_next||[]).push([[42277],{29439:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>r,contentTitle:()=>s,default:()=>h,frontMatter:()=>o,metadata:()=>c,toc:()=>l});var i=n(85893),a=n(11151);const o={id:"navigation-lifecycle",title:"Navigation lifecycle",sidebar_label:"Navigation lifecycle"},s=void 0,c={id:"navigation-lifecycle",title:"Navigation lifecycle",description:"In the previous section, we worked with a stack navigator that has two screens (Home and Details) and learned how to use this.props.navigation.navigate('RouteName') to navigate between the routes.",source:"@site/versioned_docs/version-3.x/navigation-lifecycle.md",sourceDirName:".",slug:"/navigation-lifecycle",permalink:"/docs/3.x/navigation-lifecycle",draft:!1,unlisted:!1,editUrl:"https://github.com/react-navigation/react-navigation.github.io/edit/main/versioned_docs/version-3.x/navigation-lifecycle.md",tags:[],version:"3.x",frontMatter:{id:"navigation-lifecycle",title:"Navigation lifecycle",sidebar_label:"Navigation lifecycle"},sidebar:"version-3.x-docs",previous:{title:"Moving between screens",permalink:"/docs/3.x/navigating"},next:{title:"Passing parameters to routes",permalink:"/docs/3.x/params"}},r={},l=[{value:"Example scenario",id:"example-scenario",level:2},{value:"React Navigation lifecycle events",id:"react-navigation-lifecycle-events",level:2},{value:"Summary",id:"summary",level:2}];function d(e){const t={a:"a",code:"code",h2:"h2",li:"li",p:"p",pre:"pre",ul:"ul",...(0,a.a)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(t.p,{children:["In the previous section, we worked with a stack navigator that has two screens (",(0,i.jsx)(t.code,{children:"Home"})," and ",(0,i.jsx)(t.code,{children:"Details"}),") and learned how to use ",(0,i.jsx)(t.code,{children:"this.props.navigation.navigate('RouteName')"})," to navigate between the routes."]}),"\n",(0,i.jsxs)(t.p,{children:["An important question in this context is: what happens with ",(0,i.jsx)(t.code,{children:"Home"})," when we navigate away from it, or when we come back to it? How does a route find out that a user is leaving it or coming back to it?"]}),"\n",(0,i.jsxs)(t.p,{children:["Coming to react-navigation from the web, you may assume that when user navigates from route A to route B, A will unmount (its ",(0,i.jsx)(t.code,{children:"componentWillUnmount"})," is called) and A will mount again when user comes back to it. While these React lifecycle methods are still valid and are used in react-navigation, their usage differs from the web. This is driven by more complex needs of mobile navigation."]}),"\n",(0,i.jsx)(t.h2,{id:"example-scenario",children:"Example scenario"}),"\n",(0,i.jsxs)(t.p,{children:["Consider a stack navigator with screens A and B. After navigating to A, its ",(0,i.jsx)(t.code,{children:"componentDidMount"})," is called. When pushing B, its ",(0,i.jsx)(t.code,{children:"componentDidMount"})," is also called, but A remains mounted on the stack and its ",(0,i.jsx)(t.code,{children:"componentWillUnmount"})," is therefore not called."]}),"\n",(0,i.jsxs)(t.p,{children:["When going back from B to A, ",(0,i.jsx)(t.code,{children:"componentWillUnmount"})," of B is called, but ",(0,i.jsx)(t.code,{children:"componentDidMount"})," of A is not because A remained mounted the whole time."]}),"\n",(0,i.jsx)(t.p,{children:"Similar results can be observed (in combination) with other navigators as well. Consider a tab navigator with two tabs, where each tab is a stack navigator:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-jsx",children:"const HomeStack = createStackNavigator({\n  Home: HomeScreen,\n  Details: DetailsScreen,\n});\n\nconst SettingsStack = createStackNavigator({\n  Settings: SettingsScreen,\n  Profile: ProfileScreen,\n});\n\nconst TabNavigator = createBottomTabNavigator({\n  Home: HomeStack,\n  Settings: SettingsStack,\n});\n"})}),"\n",(0,i.jsxs)(t.p,{children:["We start on the ",(0,i.jsx)(t.code,{children:"HomeScreen"})," and navigate to ",(0,i.jsx)(t.code,{children:"DetailsScreen"}),". Then we use the tab bar to switch to the ",(0,i.jsx)(t.code,{children:"SettingsScreen"})," and navigate to ",(0,i.jsx)(t.code,{children:"ProfileScreen"}),". After this sequence of operations is done, all 4 of the screens are mounted! If you use the tab bar to switch back to the ",(0,i.jsx)(t.code,{children:"HomeStack"}),", you'll notice you'll be presented with the ",(0,i.jsx)(t.code,{children:"DetailsScreen"})," - the navigation state of the ",(0,i.jsx)(t.code,{children:"HomeStack"})," has been preserved!"]}),"\n",(0,i.jsx)(t.h2,{id:"react-navigation-lifecycle-events",children:"React Navigation lifecycle events"}),"\n",(0,i.jsx)(t.p,{children:'Now that we understand how React lifecycle methods work in React Navigation, let\'s answer the question we asked at the beginning: "How do we find out that a user is leaving it or coming back to it?"'}),"\n",(0,i.jsxs)(t.p,{children:["React Navigation emits events to screen components that subscribe to them. There are four different events that you can subscribe to: ",(0,i.jsx)(t.code,{children:"willFocus"}),", ",(0,i.jsx)(t.code,{children:"willBlur"}),", ",(0,i.jsx)(t.code,{children:"didFocus"})," and ",(0,i.jsx)(t.code,{children:"didBlur"}),". Read more about them in the ",(0,i.jsx)(t.a,{href:"/docs/3.x/navigation-prop#addlistener-subscribe-to-updates-to-navigation-lifecycle",children:"API reference"}),"."]}),"\n",(0,i.jsxs)(t.p,{children:["Many of your use cases may be covered with the ",(0,i.jsxs)(t.a,{href:"/docs/3.x/with-navigation-focus",children:[(0,i.jsx)(t.code,{children:"withNavigationFocus"})," HOC"]})," or the ",(0,i.jsxs)(t.a,{href:"/docs/3.x/navigation-events",children:[(0,i.jsx)(t.code,{children:"<NavigationEvents />"})," component"]})," which are a little more straightforward to use."]}),"\n",(0,i.jsx)(t.h2,{id:"summary",children:"Summary"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:["while React's lifecycle methods are still valid, React Navigation adds more lifecycle events that you can subscribe to through the ",(0,i.jsx)(t.code,{children:"navigation"})," prop."]}),"\n",(0,i.jsxs)(t.li,{children:["you may also use the ",(0,i.jsx)(t.code,{children:"withNavigationFocus"})," HOC or ",(0,i.jsx)(t.code,{children:"<NavigationEvents />"})," component to react to lifecycle changes"]}),"\n"]})]})}function h(e={}){const{wrapper:t}={...(0,a.a)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},11151:(e,t,n)=>{n.d(t,{Z:()=>c,a:()=>s});var i=n(67294);const a={},o=i.createContext(a);function s(e){const t=i.useContext(o);return i.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function c(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:s(e.components),i.createElement(o.Provider,{value:t},e.children)}}}]);