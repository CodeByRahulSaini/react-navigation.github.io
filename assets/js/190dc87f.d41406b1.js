"use strict";(self.webpackChunkreact_navigation_website_next=self.webpackChunkreact_navigation_website_next||[]).push([[74799],{69641:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>s,contentTitle:()=>c,default:()=>h,frontMatter:()=>o,metadata:()=>r,toc:()=>d});var t=i(85893),a=i(11151);const o={id:"static-configuration",title:"Static configuration",sidebar_label:"Static configuration"},c=void 0,r={id:"static-configuration",title:"Static configuration",description:"The bulk of the static configuration is done using the createXNavigator functions, e.g. createNativeStackNavigator, createBottomTabNavigator, createDrawerNavigator etc. We'll refer to these functions as createXNavigator in the rest of this guide.",source:"@site/versioned_docs/version-7.x/static-configuration.md",sourceDirName:".",slug:"/static-configuration",permalink:"/docs/7.x/static-configuration",draft:!1,unlisted:!1,editUrl:"https://github.com/react-navigation/react-navigation.github.io/edit/main/versioned_docs/version-7.x/static-configuration.md",tags:[],version:"7.x",frontMatter:{id:"static-configuration",title:"Static configuration",sidebar_label:"Static configuration"},sidebar:"docs",previous:{title:"Drawer Layout",permalink:"/docs/7.x/drawer-layout"},next:{title:"NavigationContainer",permalink:"/docs/7.x/navigation-container"}},s={},d=[{value:"<code>createXNavigator</code>",id:"createxnavigator",level:2},{value:"<code>screens</code>",id:"screens",level:3},{value:"<code>groups</code>",id:"groups",level:3},{value:"Screen configuration",id:"screen-configuration",level:3},{value:"<code>screen</code>",id:"screen",level:4},{value:"<code>linking</code>",id:"linking",level:4},{value:"<code>if</code>",id:"if",level:4},{value:"<code>options</code>",id:"options",level:4},{value:"<code>initialParams</code>",id:"initialparams",level:4},{value:"<code>getId</code>",id:"getid",level:4},{value:"<code>listeners</code>",id:"listeners",level:4},{value:"<code>createStaticNavigation</code>",id:"createstaticnavigation",level:2},{value:"<code>createComponentForStaticNavigation</code>",id:"createcomponentforstaticnavigation",level:2},{value:"<code>createPathConfigForStaticNavigation</code>",id:"createpathconfigforstaticnavigation",level:2}];function l(e){const n={a:"a",code:"code",h2:"h2",h3:"h3",h4:"h4",li:"li",p:"p",pre:"pre",ul:"ul",...(0,a.a)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsxs)(n.p,{children:["The bulk of the static configuration is done using the ",(0,t.jsx)(n.code,{children:"createXNavigator"})," functions, e.g. ",(0,t.jsx)(n.a,{href:"/docs/7.x/native-stack-navigator",children:(0,t.jsx)(n.code,{children:"createNativeStackNavigator"})}),", ",(0,t.jsx)(n.a,{href:"/docs/7.x/bottom-tab-navigator",children:(0,t.jsx)(n.code,{children:"createBottomTabNavigator"})}),", ",(0,t.jsx)(n.a,{href:"/docs/7.x/drawer-navigator",children:(0,t.jsx)(n.code,{children:"createDrawerNavigator"})})," etc. We'll refer to these functions as ",(0,t.jsx)(n.code,{children:"createXNavigator"})," in the rest of this guide."]}),"\n",(0,t.jsx)(n.h2,{id:"createxnavigator",children:(0,t.jsx)(n.code,{children:"createXNavigator"})}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"createXNavigator"})," functions take one argument, which is an object with the following properties:"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Same props as the navigator component, e.g. ",(0,t.jsx)(n.code,{children:"id"}),", ",(0,t.jsx)(n.code,{children:"initialRouteName"}),", ",(0,t.jsx)(n.code,{children:"screenOptions"})," etc. See the docs for each navigator for more details on the props they accept."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"screens"})," - an object containing configuration for each screen in the navigator."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"groups"})," - an optional object containing groups of screens (equivalent to ",(0,t.jsx)(n.a,{href:"/docs/7.x/group",children:(0,t.jsx)(n.code,{children:"Group"})})," in the dynamic API)."]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"For example:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:"const RootStack = createNativeStackNavigator({\n  initialRouteName: 'Home',\n  screenOptions: {\n    headerTintColor: 'white',\n    headerStyle: {\n      backgroundColor: 'tomato',\n    },\n  },\n  screens: {\n    Home: HomeScreen,\n    Profile: ProfileScreen,\n  },\n});\n"})}),"\n",(0,t.jsx)(n.h3,{id:"screens",children:(0,t.jsx)(n.code,{children:"screens"})}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"screens"})," object can contain key value pairs where the key is the name of the screen and the value can be several things:"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"A component to render:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:"const RootStack = createNativeStackNavigator({\n  screens: {\n    Home: HomeScreen,\n  },\n});\n"})}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:["A navigator configured using ",(0,t.jsx)(n.code,{children:"createXNavigator"})," for nested navigators:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:"const HomeTabs = createBottomTabNavigator({\n  screens: {\n    Groups: GroupsScreen,\n    Chats: ChatsScreen,\n  },\n});\n\nconst RootStack = createNativeStackNavigator({\n  screens: {\n    Home: HomeTabs,\n  },\n});\n"})}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"An object containing configuration for the screen. This configuration contains the various properties:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:"const RootStack = createNativeStackNavigator({\n  screens: {\n    Home: {\n      screen: HomeScreen,\n      linking: {\n        path: 'home',\n      },\n    },\n  },\n});\n"})}),"\n",(0,t.jsxs)(n.p,{children:["See ",(0,t.jsx)(n.a,{href:"#screen-configuration",children:"Screen configuration"})," for more details."]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"groups",children:(0,t.jsx)(n.code,{children:"groups"})}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"groups"})," object can contain key value pairs where the key is the name of the group and the value is the group configuration. The group configuration can contain the following properties:"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"if"})," - this can be used to conditionally render the group and works the same as the ",(0,t.jsxs)(n.a,{href:"#if",children:[(0,t.jsx)(n.code,{children:"if"})," property in the screen configuration"]}),"."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"screenOptions"})," - default options for all screens under this group."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"screens"})," - an object containing configuration for each screen in the group. The configuration is the same as the ",(0,t.jsxs)(n.a,{href:"#screens",children:[(0,t.jsx)(n.code,{children:"screens"})," object in the navigator configuration"]}),"."]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"Example:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:"const RootStack = createNativeStackNavigator({\n  screens: {\n    Home: HomeScreen,\n    Profile: ProfileScreen,\n  },\n  groups: {\n    Guest: {\n      if: useIsGuest,\n      screenOptions: {\n        headerShown: false,\n      },\n      screens: {\n        // ...\n      },\n    },\n    User: {\n      if: useIsUser,\n      screens: {\n        // ...\n      },\n    },\n  },\n});\n"})}),"\n",(0,t.jsxs)(n.p,{children:["The keys of the ",(0,t.jsx)(n.code,{children:"groups"})," object (e.g. ",(0,t.jsx)(n.code,{children:"Guest"}),", ",(0,t.jsx)(n.code,{children:"User"}),") are used as the ",(0,t.jsx)(n.a,{href:"/docs/7.x/group#navigationkey",children:(0,t.jsx)(n.code,{children:"navigationKey"})})," for the group - this means if a screen is defined in 2 groups and the groups use the ",(0,t.jsx)(n.a,{href:"#if",children:(0,t.jsx)(n.code,{children:"if"})})," property, the screen will remount if the condition changes resulting in one group being removed and other group being used. You can use any string as the key."]}),"\n",(0,t.jsx)(n.h3,{id:"screen-configuration",children:"Screen configuration"}),"\n",(0,t.jsx)(n.p,{children:"The configuration object for a screen can contain the following properties:"}),"\n",(0,t.jsx)(n.h4,{id:"screen",children:(0,t.jsx)(n.code,{children:"screen"})}),"\n",(0,t.jsx)(n.p,{children:"The React component or navigator to render for the screen:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:"const RootStack = createNativeStackNavigator({\n  screens: {\n    Home: {\n      screen: HomeScreen,\n    },\n  },\n});\n"})}),"\n",(0,t.jsxs)(n.p,{children:["The screen components defined with the static configuration receive the ",(0,t.jsx)(n.a,{href:"/docs/7.x/route-object",children:(0,t.jsx)(n.code,{children:"route"})})," prop. Unlike the dynamic API, they don't get the ",(0,t.jsx)(n.code,{children:"navigation"})," object as prop and it must be accessed via the ",(0,t.jsx)(n.a,{href:"/docs/7.x/use-navigation",children:(0,t.jsx)(n.code,{children:"useNavigation"})})," hook."]}),"\n",(0,t.jsx)(n.h4,{id:"linking",children:(0,t.jsx)(n.code,{children:"linking"})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.a,{href:"/docs/7.x/configuring-links",children:"Linking configuration"})," for the screen. It can be either a string for a path or an object with the linking configuration:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:"const RootStack = createNativeStackNavigator({\n  screens: {\n    Profile: {\n      screen: ProfileScreen,\n      linking: {\n        path: 'u/:userId',\n        parse: {\n          userId: (id) => id.replace(/^@/, ''),\n        },\n        stringify: {\n          userId: (id) => `@${id}`,\n        },\n      },\n    },\n    Chat: {\n      screen: ChatScreen,\n      linking: 'chat/:chatId',\n    },\n  },\n});\n"})}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"linking"})," object supports the same configuration options described in ",(0,t.jsx)(n.a,{href:"/docs/7.x/configuring-links",children:"Configuring links"})," such as ",(0,t.jsx)(n.code,{children:"parse"}),", ",(0,t.jsx)(n.code,{children:"stringify"})," and ",(0,t.jsx)(n.code,{children:"exact"}),"."]}),"\n",(0,t.jsxs)(n.p,{children:["To make deep links work on native apps, you also need to ",(0,t.jsx)(n.a,{href:"/docs/7.x/deep-linking",children:"configure your app"})," and pass ",(0,t.jsx)(n.code,{children:"prefixes"})," to the navigation component returned by ",(0,t.jsx)(n.a,{href:"/docs/7.x/static-configuration#createstaticnavigation",children:(0,t.jsx)(n.code,{children:"createStaticNavigation"})}),":"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:"const Navigation = createStaticNavigation(RootStack);\n\nconst linking = {\n  prefixes: ['https://example.com', 'example://'],\n};\n\nfunction App() {\n  return <Navigation linking={linking} />;\n}\n"})}),"\n",(0,t.jsx)(n.h4,{id:"if",children:(0,t.jsx)(n.code,{children:"if"})}),"\n",(0,t.jsx)(n.p,{children:"Callback to determine whether the screen should be rendered or not. It doesn't receive any arguments. This can be useful for conditional rendering of screens, e.g. - if you want to render a different screen for logged in users."}),"\n",(0,t.jsx)(n.p,{children:"You can use a custom hook to use custom logic to determine the return value:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:"const useIsLoggedIn = () => {\n  const { isLoggedIn } = React.useContext(AuthContext);\n\n  return isLoggedIn;\n};\n\nconst RootStack = createNativeStackNavigator({\n  screens: {\n    Home: {\n      screen: HomeScreen,\n      if: useIsLoggedIn,\n    },\n  },\n});\n"})}),"\n",(0,t.jsxs)(n.p,{children:["The above example will only render the ",(0,t.jsx)(n.code,{children:"HomeScreen"})," if the user is logged in."]}),"\n",(0,t.jsxs)(n.p,{children:["For more details, see ",(0,t.jsx)(n.a,{href:"/docs/7.x/auth-flow?config=static",children:"Authentication flow"}),"."]}),"\n",(0,t.jsx)(n.h4,{id:"options",children:(0,t.jsx)(n.code,{children:"options"})}),"\n",(0,t.jsx)(n.p,{children:"Options to configure how the screen gets presented in the navigator. It accepts either an object or a function returning an object:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:"const RootStack = createNativeStackNavigator({\n  screens: {\n    Home: {\n      screen: HomeScreen,\n      options: {\n        title: 'Awesome app',\n      },\n    },\n  },\n});\n"})}),"\n",(0,t.jsxs)(n.p,{children:["When you pass a function, it'll receive the ",(0,t.jsx)(n.a,{href:"/docs/7.x/route-object",children:(0,t.jsx)(n.code,{children:"route"})}),", ",(0,t.jsx)(n.a,{href:"/docs/7.x/navigation-object",children:(0,t.jsx)(n.code,{children:"navigation"})})," and ",(0,t.jsx)(n.a,{href:"/docs/7.x/themes",children:(0,t.jsx)(n.code,{children:"theme"})})," as arguments:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:"const RootStack = createNativeStackNavigator({\n  screens: {\n    Profile: {\n      screen: ProfileScreen,\n      options: ({ route, navigation, theme }) => ({\n        title: route.params.userId,\n      }),\n    },\n  },\n});\n"})}),"\n",(0,t.jsxs)(n.p,{children:["See ",(0,t.jsx)(n.a,{href:"/docs/7.x/screen-options",children:"Options for screens"})," for more details and examples."]}),"\n",(0,t.jsx)(n.h4,{id:"initialparams",children:(0,t.jsx)(n.code,{children:"initialParams"})}),"\n",(0,t.jsxs)(n.p,{children:["Initial params to use for the screen. If a screen is used as ",(0,t.jsx)(n.code,{children:"initialRouteName"}),", it'll contain the params from ",(0,t.jsx)(n.code,{children:"initialParams"}),". If you navigate to a new screen, the params passed are shallow merged with the initial params."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:"const RootStack = createNativeStackNavigator({\n  screens: {\n    Details: {\n      screen: DetailsScreen,\n      initialParams: { itemId: 5 },\n    },\n  },\n});\n"})}),"\n",(0,t.jsx)(n.h4,{id:"getid",children:(0,t.jsx)(n.code,{children:"getId"})}),"\n",(0,t.jsx)(n.p,{children:"Callback to return an unique ID to use for the screen. It receives an object with the route params:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:"const RootStack = createNativeStackNavigator({\n  screens: {\n    Profile: {\n      screen: ProfileScreen,\n      getId: ({ params }) => params.userId,\n    },\n  },\n});\n"})}),"\n",(0,t.jsxs)(n.p,{children:["By default, calling ",(0,t.jsx)(n.code,{children:"navigate('ScreenName', params)"})," identifies the screen by its name, and navigates to the existing screen instead of adding a new one. If you specify ",(0,t.jsx)(n.code,{children:"getId"})," and it doesn't return ",(0,t.jsx)(n.code,{children:"undefined"}),", the screen is identified by both the screen name and the returned ID."]}),"\n",(0,t.jsxs)(n.p,{children:["This is useful for preventing multiple instances of the same screen in the navigator, e.g. - when ",(0,t.jsx)(n.code,{children:"params.userId"})," is used as an ID, subsequent navigation to the screen with the same ",(0,t.jsx)(n.code,{children:"userId"})," will navigate to the existing screen instead of adding a new one to the stack. If the navigation was with a different ",(0,t.jsx)(n.code,{children:"userId"}),", then it'll add a new screen."]}),"\n",(0,t.jsx)(n.h4,{id:"listeners",children:(0,t.jsx)(n.code,{children:"listeners"})}),"\n",(0,t.jsx)(n.p,{children:"Event listeners to subscribe to. It takes an object with the event names as keys and the listener callbacks as values:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:"const BottomTab = createBottomTabNavigator({\n  screens: {\n    Chat: {\n      screen: ChatScreen,\n      listeners: {\n        tabPress: (e) => {\n          // Prevent default action\n          e.preventDefault();\n        },\n      },\n    },\n  },\n});\n"})}),"\n",(0,t.jsx)(n.h2,{id:"createstaticnavigation",children:(0,t.jsx)(n.code,{children:"createStaticNavigation"})}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"createStaticNavigation"})," function takes the static config returned by ",(0,t.jsx)(n.code,{children:"createXNavigator"})," functions and returns a React component to render:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:"const Navigation = createStaticNavigation(RootStack);\n\nfunction App() {\n  return <Navigation />;\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:["This component is a wrapper around the ",(0,t.jsx)(n.code,{children:"NavigationContainer"})," component and accepts the ",(0,t.jsxs)(n.a,{href:"/docs/7.x/navigation-container",children:["same props and ref as the ",(0,t.jsx)(n.code,{children:"NavigationContainer"})]})," component. There's however one difference - the ",(0,t.jsx)(n.code,{children:"linking"})," prop accepted by this component doesn't take a ",(0,t.jsx)(n.code,{children:"config"})," property. Instead, the linking config is automatically inferred from the static config."]}),"\n",(0,t.jsxs)(n.p,{children:["This is intended to be rendered once at the root of your app similar to how you'd use ",(0,t.jsx)(n.code,{children:"NavigationContainer"})," component."]}),"\n",(0,t.jsx)(n.h2,{id:"createcomponentforstaticnavigation",children:(0,t.jsx)(n.code,{children:"createComponentForStaticNavigation"})}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"createComponentForStaticNavigation"})," function takes the static config returned by ",(0,t.jsx)(n.code,{children:"createXNavigator"})," functions and returns a React component to render. The second argument is a name for the component that'd be used in React DevTools:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:"const RootStackNavigator = createComponentForStaticNavigation(\n  RootStack,\n  'RootNavigator'\n);\n"})}),"\n",(0,t.jsx)(n.p,{children:"The returned component doesn't take any props. All of the configuration is inferred from the static config. It's essentially the same as defining a component using the dynamic API."}),"\n",(0,t.jsxs)(n.p,{children:["This looks similar to ",(0,t.jsx)(n.code,{children:"createStaticNavigation"})," however they are very different. When using static configuration, you'd never use this function directly. The only time you'd use this is if you're migrating away from static configuration and want to reuse existing code you wrote instead of rewriting it to the dynamic API. See ",(0,t.jsx)(n.a,{href:"/docs/7.x/combine-static-with-dynamic",children:"Combining static and dynamic APIs"})," for more details."]}),"\n",(0,t.jsx)(n.h2,{id:"createpathconfigforstaticnavigation",children:(0,t.jsx)(n.code,{children:"createPathConfigForStaticNavigation"})}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"createPathConfigForStaticNavigation"})," function takes the static config returned by ",(0,t.jsx)(n.code,{children:"createXNavigator"})," functions and returns a path config object that can be used within the linking config."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:"const config = {\n  screens: {\n    Home: {\n      screens: createPathConfigForStaticNavigation(HomeTabs),\n    },\n  },\n};\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Similar to ",(0,t.jsx)(n.code,{children:"createComponentForStaticNavigation"}),", this is intended to be used when migrating away from static configuration. See ",(0,t.jsx)(n.a,{href:"/docs/7.x/combine-static-with-dynamic",children:"Combining static and dynamic APIs"})," for more details."]})]})}function h(e={}){const{wrapper:n}={...(0,a.a)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(l,{...e})}):l(e)}},11151:(e,n,i)=>{i.d(n,{Z:()=>r,a:()=>c});var t=i(67294);const a={},o=t.createContext(a);function c(e){const n=t.useContext(o);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:c(e.components),t.createElement(o.Provider,{value:n},e.children)}}}]);